---
title: "Transition matrices"
author: "Pernille Berg Lassen"
date: "25/3/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
convertToMatrix <- function(data)
{
  tmp0 <- data
  tmp <- tmp0 %>% group_by(participant) %>% mutate(to = lead(AOI))
  tmp2 <- tmp[complete.cases(tmp), ]
  with(tmp2, table(AOI, to))
  out_mat <- as.matrix(with(tmp2, table(AOI, to)))
  diag(out_mat) <- 0
  return(out_mat)
}

convertToProbMatrix <- function(data)
{
  prob_mat <- data / rowSums(data)
  prob_mat[is.na(prob_mat)] <- 0
  return(prob_mat)
}


trimMatrixZeros <- function(m1, m2)
{
  matrix_list <- list()
  row_col_to_remove <- NULL
  
  for(x in 1:nrow(m1))
  {
    if((rowSums(m1)[x] == 0) && (rowSums(m2)[x] == 0))
    {  
      if((colSums(m1)[x] == 0) && (colSums(m2)[x] == 0))
      {
        row_col_to_remove <- c(row_col_to_remove, x)
      }
    }
  } 
  
  if(length(row_col_to_remove) > 0)
  {
    # removed the selected rows and columns
    m1 <- m1[-row_col_to_remove, ]; m1 <- m1[, -row_col_to_remove] 
    m2 <- m2[-row_col_to_remove, ]; m2 <- m2[, -row_col_to_remove] 
    
    # store in list entries
    matrix_list[[1]] <- m1
    matrix_list[[2]] <- m2
    
    return(matrix_list)
  }
  return(FALSE)
}

```

```{r}
determineImageOffset <- function(data, stimuli)
{
  # load and plot the stimulus image
  stimuli_image_str <- gsub("abstract", "abs", current_stimuli_data$image)
  stimuli_image_str <- gsub("_", "", stimuli_image_str)
  stimuli_image_str <- paste('screenshot_',stimuli_image_str, sep = "")
  bkg_img <- readPNG(paste0(getwd(), "/DataBsC/heatmaps_scanpaths_images/", stimuli_image_str, ".png"), info = TRUE)
  plot.new()
  limits <- par()
  
  # get the dimensions
  dims <- attr(bkg_img, "dim")
  
  # get vertical offset
  for(i in 1:dims[1])
  {
    # get the center point of image and pixel value
    row_offset <- floor(dims[2] / 2)
    px <- bkg_img[i, row_offset, 1:3]
    
    # get offset if pixel colour is not black
    if((px[1] > 0) || (px[2] > 0) || (px[3] > 0))
    {
      vertical_offset <- (i - 1)
      break
    }
  }
  
  # get horizontal offset
  for(i in 1:dims[2])
  {
    # get the center point of image and pixel value
    col_offset <- floor(dims[1] / 2)
    px <- bkg_img[col_offset, i, 1:3]
    
    # get offset if pixel colour is not black
    if((px[1] > 0) || (px[2] > 0) || (px[3] > 0))
    {
      horizontal_offset <- (i - 1)
      break
    }
  }
  return(c(horizontal_offset, vertical_offset))
}

#This doesn't work - prints only the bkg image, not the grid - added a solution below
drawGrid <- function(grid_args, stimuli)
{
  # load and plot the stimulus image
  stimuli_image_str <- gsub("abstract", "abs", stimuli$image)
  stimuli_image_str <- gsub("_", "", stimuli_image_str)
  stimuli_image_str <- paste('screenshot_',stimuli_image_str, sep = "")
  bkg_img <- readPNG(paste0(getwd(), "/DataBsC/heatmaps_scanpaths_images/", stimuli_image_str, ".png"), info = TRUE) #Change working directiry accordingly
  limits <- par()
  rasterImage(bkg_img, limits$usr[1], limits$usr[3], limits$usr[2], limits$usr[4])
  dims <- attr(bkg_img, "dim")
}

determineGridOffset <- function(width, height, grid_len)
{
  x_offset <- (width / grid_len) - floor(width / grid_len)
  y_offset <- (height / grid_len) - floor(height / grid_len)
  return(c(x_offset, y_offset))
}



```

```{r}

detectCellHits <- function(cell_x, cell_y, cell_len, data)
{
  # extract data
  data <- data[1, c("PositionX", "PositionY")] #Name of the coloumn that contains x and y coordinates
  fixation_x <- data[1, 1]
  fixation_y <- data[1, 2]
  
  # return no hit for any missing data
  if(is.na(fixation_x) || is.na(fixation_y))
  {
    return(FALSE)
  }
  
  # check present inside cell 
  if((fixation_x > cell_x && fixation_x < (cell_x + cell_len)) && 
     (fixation_y > cell_y && fixation_y < (cell_y + cell_len)))
  {
    return(TRUE)
  }
  return(FALSE)
}

addAOIlabels <- function(letter_len) 
{
  a <- rep(LETTERS, length.out = letter_len)
  grp <- cumsum(a == "A")
  vapply(seq_along(a), function(x) paste(rep(a[x], grp[x]), collapse = ""), character(1L))
}

```

```{r}



```

```{r}
generateTransitionData <- function(data, condition_num, grid_args, perm_trans = FALSE){
  data = current_stimuli_data
  condition_num = 1
  perm_trans = FALSE
  data_frames <- list()
  mat <- matrix(addAOIlabels(grid_args$num_cells), nrow = grid_args$num_rows, ncol = grid_args$num_cols, byrow = TRUE)
  
  participant_vector <- NULL
  AOI_vector <- NULL
  
  if(!perm_trans){
        condition <- data[data$condition == condition_num, ]
    } else {
        condition <- data
    }
  
  participants <- as.vector(condition[!duplicated(condition$ID), "ID"]) #Name of ID column
  
  for (i in 1:length(participants)){
    participant_data <- data[data$ID == participants[2],]
    for (j in 1:nrow(participant_data)){
      for (m in grid_args$num_rows:1){
        for (n in 1:grid_args$num_cols){
          cell_x <- grid_args$images_offsets[1] + grid_args$grid_offsets[1] + (grid_args$dims * (n - 1))
          cell_y <- grid_args$images_offsets[2] + grid_args$grid_offsets[2] + (grid_args$dims * (m - 1))
          
          hit <- detectCellHits(cell_x, cell_y, grid_args$dims, participant_data[j, ])
          if(hit){
             AOI_vector <- c(AOI_vector, mat[m, n])
          }
        }
      }
    }
    AOIs <- addAOIlabels(grid_args$num_cells)
    participant_vector <- rep(participants[i], length(AOI_vector))
    df <- data.frame(participant = participant_vector, AOI = AOI_vector)
    df$AOI <- factor(df$AOI, levels = AOIs)
    
    # add data frame to list
    data_frames[[i]] <- df
    participant_data <- NULL
    AOI_vector <- NULL
  }
  hit_data <- ldply(data_frames, data.frame)
  return(hit_data)  
}


```


```{r}
current_stimuli_data <- Fix_df[Fix_df$image == "abstract_12",] #Contain all fix for one image for both conditions
current_stimuli_data$MediaWidth <- 935 #Add to actual dataset

current_stimuli_data$MediaHeight <- 675 #Add to actual dataset
  
  # calculate dimensions / offsets
grid_args <- list()
grid_args[["w"]] <- current_stimuli_data[1, "MediaWidth"] 
grid_args[["h"]] <- current_stimuli_data[1, "MediaHeight"]
grid_args[["min_dim"]] <- min(grid_args$w, grid_args$h)
  
grid_args[["dims"]] <- gridsizes[1]
grid_args[["images_offsets"]] <- determineImageOffset(grid_args$dims, current_stimuli_data)
grid_args[["grid_offsets"]] <- determineGridOffset(grid_args$w, grid_args$h, grid_args$dims)

if(grid_args[["h"]] < grid_args[["w"]]){
  grid_args[["num_rows"]] <- 
    floor((grid_args$min_dim -((grid_args$images_offsets[2]*2)+(grid_args$grid_offsets[2]*2)))/grid_args$dims)
  grid_args[["num_cols"]] <- 
    grid_args[["num_rows"]]
  } else {
    grid_args[["num_cols"]] <- 
      floor((grid_args$min_dim-((grid_args$images_offsets[1]*2)+(grid_args$grid_offsets[1]*2)))/grid_args$dims)
    grid_args[["num_rows"]] <- 
      grid_args[["num_cols"]]
  }

grid_args[["num_cells"]] <- grid_args$num_rows * grid_args$num_cols

conditions1_participants <- current_stimuli_data[current_stimuli_data$condition == "1", ]
conditions1_participants <- as.vector(conditions1_participants[!duplicated(conditions1_participants$ID), "ID"])

cond_one <- generateTransitionData(current_stimuli_data, 1, grid_args)
cond_zero <- generateTransitionData(current_stimuli_data, 0, grid_args)
```


```{r}

```
